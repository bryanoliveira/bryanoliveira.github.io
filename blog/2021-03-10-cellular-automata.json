{"html":"<p>A <a href=\"https://en.wikipedia.org/wiki/Cellular_automaton\">Cellular Automata</a> program built with C++, OpenGL, CUDA and OpenMP. It&#39;s built to run on a GPU but it also supports multithreaded CPU-only execution. On the right there&#39;s an example execution of <a href=\"https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\">Conway&#39;s Game of Life</a> on a 100x100 randomly initialised lattice.</p>\n<p>The main objective of this project is to allow scaling up to a reasonably large number of cells while maintaining the code legibility and allowing for further customisations. It supports command-line arguments to set up quick configs (run <code>./automata -h</code> for details) like headless mode (which is significantly faster) and initial patterns (which can be loaded from the <code>patterns</code> folder). It doesn&#39;t yet support the definition of evolution rules at runtime or lattice size inference, but I&#39;m working on that.</p>\n<p>This program can currently evolve a dense &amp; high entropy 182.25 million cell Game of Life grid (13500x13500) with rendering enabled with up to 729 generations per second on a Ryzen 7 3700X / RTX 3080 using up to 200MB RAM and 8.5GB VRAM (which is the actual scaling limiter).</p>\n<p>The ability to evolve and render such large grids allows the program to run some really interesting patterns, like evolving the Game of Life <em>within</em> the Game of Life:</p>\n<div align=\"center\">\n    <img class=\"text-img mw-75\" src=\"/img/zoom.gif\">\n</div>\n\n<p>In the GIF above we&#39;re running a 12300x12300 grid using Game of Life rules to evolve a pattern known as <a href=\"http://b3s23life.blogspot.com/2006_09_01_archive.html\">Meta-Toad</a>. It uses a grid of <a href=\"https://www.conwaylife.com/wiki/OTCA_metapixel\">OTCA Metapixels</a> and requires about 35 thousand generations of the underlying automaton to represent a single generation of the meta-grid. The pattern being evolved by the meta-grid is known as <a href=\"https://www.conwaylife.com/wiki/Toad\">Toad</a>:</p>\n<div align=\"center\">\n    <img class=\"text-img\" src=\"https://github.com/bryanoliveira/cellular-automata/raw/master/images/toad.gif\" width=\"150\">\n</div>\n\n<p>This program also supports a benchmark mode (<code>-b</code> option), which outputs the total and average evolution and rendering timings to stdout. Combined with <code>benchmark.sh</code> and <code>benchmark_visualize.ipynb</code>, it is possible to plot speedups and evolution times for different lattice sizes. Currently, the GPU implementation achieves a speedup up to 627x over the single-core CPU implementation.</p>\n<div align=\"center\">\n<br/>\n<img class=\"text-img mw-50\" src=\"https://raw.githubusercontent.com/bryanoliveira/cellular-automata/master/images/lat_hl_evo_speedup.png\">\n<img class=\"text-img mw-50\" src=\"https://raw.githubusercontent.com/bryanoliveira/cellular-automata/master/images/lat_hl_evo_avg.png\">\n</div>\n<br/>\n\n<blockquote>\n<p>Speedup over serial (left) and average grid evolution time in milliseconds (right) for lattice sizes 32x32, 64x64, ..., 4096x4096 and 1000 generations, using logarithmic X and Y axis. &quot;# Threads&quot; refers to the number of threads available for OpenMP CPU (Ryzen 7 3700X) runs while &quot;GPU&quot; refers to CUDA (RTX 3080) runs. For these tests, initial spawn probability was set to 0.5 and rendering was disabled.</p>\n</blockquote>\n<h2 id=\"requirements\">Requirements</h2>\n<p>To run the program you&#39;ll need:</p>\n<ul>\n<li>  Debian-like linux distro (I only tested this on Ubuntu 20)</li>\n<li>OpenGL* (GLEW, GLUT and GLM)<ul>\n<li>  e.g. <code>sudo apt-get install libglew-dev freeglut3-dev libglm-dev</code></li>\n</ul>\n</li>\n<li>  <a href=\"https://developer.nvidia.com/cuda-downloads\">CUDA</a>** (nvcc) and CUDA runtime libraries</li>\n</ul>\n<p>To build it from source you&#39;ll also need:</p>\n<ul>\n<li>g++ (C++ 17) and <em>make</em><ul>\n<li>  e.g. <code>sudo apt install build-essential</code></li>\n</ul>\n</li>\n<li>  Boost C++ Library (program_options module)</li>\n<li>  <a href=\"https://github.com/gabime/spdlog\">spdlog</a></li>\n</ul>\n<p>*It is possible to run this program in headless-only mode, so if your machine doesn&#39;t support rendering (e.g. Colab runtimes) you may skip the OpenGL installation step. For that to work you must compile the program with the <code>HEADLESS_ONLY</code> flag set (e.g. <code>make automata HEADLESS_ONLY=1</code>).</p>\n<p>**It is also possible to run this program in CPU-only mode, so if you don&#39;t have a CUDA-capable video card you may skip the CUDA installation step. For that to work you will need to compile the program with the <code>CPU_ONLY</code> flag set (e.g. <code>make automata CPU_ONLY=1</code>).</p>\n<h2 id=\"usage\">Usage</h2>\n<h3 id=\"building-from-source\">Building From Source</h3>\n<ul>\n<li>  Install the requirements</li>\n<li>  Clone this repository</li>\n<li>Building and executing:<ul>\n<li>  Run <code>make</code> to build and run</li>\n<li>  Run <code>make automata</code> to build</li>\n<li>  Run <code>make run</code> to run with default parameters</li>\n<li>  Run <code>make clean</code> to remove generated files</li>\n<li>  Run <code>make profile</code> to run <a href=\"https://developer.nvidia.com/nsight-systems\">NVIDIA&#39;s nsys</a> profiling.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"executing-a-pre-built-binary-linux-x64--cuda-only\">Executing a pre-built binary (Linux x64 + CUDA only)</h3>\n<ul>\n<li>  Download <code>cellular-automata-linux64.zip</code> from the <a href=\"https://github.com/bryanoliveira/cellular-automata/releases\">latest release</a></li>\n<li>  Extract the executable (<code>automata</code>) and the <code>patterns</code> folder</li>\n<li>  Install OpenGL and CUDA from the requirements above</li>\n<li>  Run <code>./automata -h</code> to see all the available options</li>\n<li>  Run the program with <code>./automata --render</code>.</li>\n</ul>\n<p>You may want to set the number of available threads when running in CPU. For that, set the environment variable <code>OMP_NUM_THREADS</code> (e.g. <code>env OMP_NUM_THREADS=8 ./automata -r</code>).</p>\n<p>If your GPU has enough VRAM (&gt;= 8 GB), you may be able to reproduce the Meta-Toad simulation above. Run <code>./automata -r -x 12300 -y 12300 -p 0 -f patterns/meta-toad.rle --skip-frames 80</code> to try it out!</p>\n<h3 id=\"runtime-controls\">Runtime Controls</h3>\n<ul>\n<li>Basic controls:<ul>\n<li>  <strong>space</strong> pauses/resumes the simulation;</li>\n<li>  <strong>enter/return</strong> runs a single generation;</li>\n<li>  <strong>left mouse click</strong> translates the grid relative to the max resolution</li>\n<li>  <strong>ctrl + left mouse click</strong> translates the camera relative to the world</li>\n<li>  <strong>mouse scroll</strong> zooms the grid in and out, relative to the max resolution</li>\n<li>  <strong>ctrl + mouse scroll</strong> zooms the camera, relative to the world</li>\n<li>  <strong>middle mouse click</strong> resets scale and translation</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"next-steps\">Next steps</h2>\n<p>There is still much room for improvement. This includes better memory management, use of CPU parallelism and automated tests. My next steps include (but are not limited to):</p>\n<ul>\n<li>  Addition of unit tests (in progress)</li>\n<li>  Usage of templates to abstract grid data types (e.g. cells should be represented with 1 bit instead of 8)</li>\n<li>  Usage of SM shared memory to explore data locality</li>\n<li>  Support for flexible rule definition</li>\n<li>  Support for infinite grids (e.g. storing only active cells)</li>\n<li>  Support for 3-D and N-D grids</li>\n</ul>\n<h2 id=\"references\">References</h2>\n<ul>\n<li>  What are <a href=\"https://en.wikipedia.org/wiki/Cellular_automaton\">Cellular Automata</a>?</li>\n<li>  What is <a href=\"https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\">Conway&#39;s Game of Life</a>?</li>\n<li>  <a href=\"http://golly.sourceforge.net/\">Golly</a>: an open source cellular automata simulator that supports several Game of Life and other automata algorithms;</li>\n<li>  <a href=\"https://copy.sh/life/\">Life</a>: an open source JavaScript implementation of Game of Life that runs in the browser;</li>\n<li>  <a href=\"http://b3s23life.blogspot.com/2006_09_01_archive.html\">Conway&#39;s Life: Work in Progress</a>: where I got the initial pattern for the Meta-Toad;</li>\n<li>  <a href=\"https://blog.amandaghassaei.com/2020/05/01/the-recursive-universe/\">The Recursive Universe</a>: explores and explains how some of the meta-patterns work;</li>\n<li>  What are <a href=\"https://www.conwaylife.com/wiki/OTCA_metapixel\">OTCA Metapixels</a>?</li>\n</ul>\n<h2 id=\"bonus\">Bonus</h2>\n<div align=\"center\">\n<img class=\"text-img mw-100\" src=\"https://github.com/bryanoliveira/cellular-automata/raw/master/images/1000x1000.gif\"/>\n</div>\n\n<blockquote>\n<p>A 1000x1000 randomly initialized grid running Game of life.</p>\n</blockquote>\n<hr>\n<p>This program was developed during the 2021/1 Parallel Computing (CCO0455) Computer Science graduate course at Universidade Federal de Goi√°s (UFG, Brazil).</p>\n","readingTime":"6 min read","title":"Cellular Automata Framework","slug":"2021-03-10-cellular-automata","date":"2021-03-10","urls":[{"cta":"Code","url":"https://github.com/bryanoliveira/cellular-automata"},{"cta":"Executable","url":"https://github.com/bryanoliveira/cellular-automata/releases"}],"type":"Project","tags":["project","parallel","cuda","opengl","game"],"image":"/img/zoom.gif","description":"A <a href=\"https://en.wikipedia.org/wiki/Cellular_automaton\" target=\"_blank\">Cellular Automata</a> program built with C++, OpenGL, CUDA and OpenMP. The main objective of this project is to allow scaling up to a reasonably large number of cells while maintaining the code legibility and allowing for further customisations."}